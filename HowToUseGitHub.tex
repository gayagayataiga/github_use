\documentclass{ltjsarticle}
\usepackage{geometry}
\geometry{a4paper, margin=2.5cm}
\usepackage{verbatim} % for code blocks
\usepackage{tabularx} % for better tables
\usepackage{hyperref} % for clickable links
\usepackage{graphicx} % for images
\usepackage{tikz}
\usetikzlibrary{graphs, graphdrawing}
\usegdlibrary{trees}


\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,
    urlcolor=cyan,
}

\begin{document}

\title{GitとGitHub初心者向け図解ガイド：\\
最初のコマンドから共同作業まで}
\author{Taro Meidai}
\maketitle
\tableofcontents
\newpage

\section*{はじめに：あなたの旅がここから始まる}
\addcontentsline{toc}{section}{はじめに}
プログラミングやウェブ制作の世界へようこそ。これから学ぶ多くのツールの中でも、Git（ギット）とGitHub（ギットハブ）は、現代の開発者にとって欠かせない存在です。
しかし、多くの専門用語や黒い画面でのコマンド操作に、最初は戸惑いを感じるかもしれません。ご安心ください。この記事は、そんなあなたのためのガイドです。この旅では、
複雑に見える概念を身近な比喩で解きほぐし、一つひとつのコマンド操作を丁寧に図解しながら、あなたのペースで進めていきます。

まずは、この先で何度も登場する重要な言葉たちを、簡単な「翻訳機」を通して見てみましょう。これらの比喩が、あなたの理解を助ける羅針盤となるはずです。

\subsection*{Git専門用語 翻訳機}
\begin{tabularx}{\textwidth}{|l|l|X|}
\hline
専門用語 & 簡単な比喩 & 簡単な説明 \\ 
\hline
バージョン管理 (Version Control) & プロジェクトのタイムマシン & ファイルの変更履歴を記録し、いつでも過去の状態に戻せる仕組み。 \ 
リポジトリ (Repository) & プロジェクト専用の保管庫 & プロジェクトのファイルと、その全履歴が保存されている場所。 \ 
コミット (Commit) & セーブポイント & ファイルの特定の状態を「写真に撮って」履歴に保存する操作。 \ 
ブランチ (Branch) & パラレルワールド & プロジェクトの歴史を分岐させ、安全に新しい作業を進めるための仕組み。 \ 
マージ (Merge) & パラレルワールドの統合 & 分岐したブランチでの作業を、メインの歴史に合流させること。 \ 
リモート (Remote) & インターネット上の保管庫 & GitHubなど、ネットワーク上にあるリポジトリのこと。 \ 
プッシュ (Push) & ローカルからリモートへアップロード & 自分のPCで行った変更を、インターネット上のリポジトリに反映させること。 \ 
プル (Pull) & リモートからローカルへダウンロード & インターネット上のリポジトリの最新の変更を、自分のPCに持ってくること。 \ 
\hline
\end{tabularx}

\section{あなたが知らなかったタイムマシン（なぜバージョン管理が必要なのか？）}
レポートや企画書を作成している時、こんな経験はありませんか？ report_final.doc、report_final_v2.doc、report_final_REALLY_final.doc...。ファイル名がどんどん増えていき、
どれが本当に最新版なのか分からなくなる。これは、多くの人が経験する「バージョン管理」の悩みです。

\subsection{システムがないと直面する問題}
システムを使わずに手作業でファイルのバージョンを管理しようとすると、いくつかの問題が必ず発生します。
\begin{itemize}
    \item 何かを壊すことへの恐怖: 「この一行を変えたら、全部動かなくなるかも…」という不安から、変更を加えるたびにファイルのコピーを延々と作り続けることになります。
    これは非効率的で、ディスク容量も圧迫します。
    \item 過去の作業の喪失: 誤ってファイルを上書きしてしまい、以前の良かったバージョンを永遠に失ってしまうことがあります。「元に戻す」機能では救えない、致命的なミスに
    つながる可能性があります。
    \item 共同作業のカオス: 複数人で作業する場合、メールでファイルを送り合うのは悪夢の始まりです。誰かが加えた変更を自分のファイルに手作業で取り込み、気づかぬうちに
    他の人の修正を上書きしてしまうことも珍しくありません。「この変更は誰が、いつ、なぜ行ったのか？」という問いに答える術がなくなります。
\end{itemize}

\subsection{解決策：セーフティネットとしてのバージョン管理}
Gitのようなバージョン管理システム（Version Control System, VCS）は、これらの問題を解決するための強力なセーフティネットです。
\begin{itemize}
    \item 完全な履歴の記録:VCSは、ファイルに加えられた全ての変更を記録します。誰が、いつ、どのような目的で変更したのか、そのすべてが記録として残ります。これは、
    プロジェクトの信頼できる航海日誌のようなものです。
    \item 自在なタイムトラベル: プロジェクトの歴史の中の、どの時点にでも簡単かつ正確に戻ることができます。これは単なる「元に戻す」操作ではありません。歴史上の任意の
    「セーブポイント」へ瞬時にジャンプするタイムトラベルです。この機能があるからこそ、開発者は失敗を恐れずに新しいアイデアを試すことができるのです。
    \item 構造化された共同作業: VCSは、複数人が同じプロジェクトで効率的に作業するための明確なルールと仕組みを提供します。他の人の作業を上書きしてしまう心配なく、それぞれの変更を
    安全に統合できます。
\end{itemize}
バージョン管理の最も重要な価値は、技術的な機能そのものよりも、それがもたらす「心理的安全性」にあります。それは「どれだけ大胆な変更を加えても、いつでも元に戻せる」という安心感です。
この安心感が、学習と創造性を加速させます。

\section{GitとGitHubの関係（言語と国のようなもの）}
GitとGitHubはよく混同されますが、この2つは全く別のものです。
\begin{itemize}
    \item Git: プロジェクトの歴史を記録・管理するための「ソフトウェア」（コマンドラインツール）。あなたのPC上で動作します。
    \item GitHub: Gitで管理されているプロジェクトを、インターネット上で保管・共有するための「ウェブサービス」。
\end{itemize}
なぜ両方が必要なのか？Gitだけでも、個人のプロジェクトを管理することは可能です。しかし、GitHub（やGitLab、Bitbucketといった類似のサービス）を組み合わせることで、
Gitの真価が発揮されます。GitHubは、あなたのプロジェクトのバックアップ場所として機能し、他の開発者とコードを共有し、チームでの作業を円滑に進めるためのプラットフォームを
提供します。Gitというスキル（言語）を身につければ、GitHubだけでなく、GitLabなど他の「国」でも活躍できるのです。

\section{開発者のツールキットを揃えよう}
ここからは、実際に手を動かして、あなたの開発環境を整えていきましょう。職人が仕事道具を揃えるように、この一度きりのセットアップが、これからのすべての作業の基礎となります。

\subsection{パート1：Gitのインストール（道具を手に入れる）}
\subsubsection{Windowsの場合}
\begin{enumerate}
    \item インストーラーのダウンロード: まずはGitの公式サイト（\url{https://git-scm.com}）にアクセスし、Windows用のインストーラーをダウンロードします。
    \item インストールの実行: ダウンロードした .exe ファイルを実行します。インストールウィザードが起動しますが、たくさんの選択肢が表示されても、基本的に
    すべての画面でデフォルト設定のまま「Next」をクリックし続けて問題ありません。
    \item インストールの確認: インストールが完了したら、スタートメニューから「Git Bash」を起動するか、PowerShellまたはコマンドプロンプトを開きます。
    そこで以下のコマンドを入力してください。
\end{enumerate}
\begin{verbatim}
git --version
\end{verbatim}
`git version 2.XX.X` のようにバージョン情報が表示されれば、インストールは成功です。

\subsubsection{macOSの場合}
\begin{enumerate}
    \item インストールの確認: まず、ターミナルアプリを開き、`git --version` を試し、Gitがすでにインストールされていないか確認します。
    \item Homebrewのインストール（推奨）: Homebrewは、macOS用のパッケージ管理システムです。まだインストールしていない場合は、公式サイ
    ト（\url{https://brew.sh}）に記載されているコマンドを実行してインストールしてください。
    \item Gitのインストール: Homebrewがインストールできたら、ターミナルで以下のコマンドを実行するだけでGitがインストールされます。
\end{enumerate}
\begin{verbatim}
brew install git
\end{verbatim}
この方法の利点は、将来的に `brew upgrade git` という簡単なコマンドでGitを最新の状態に保てることです。

\subsection{パート2：GitHubアカウントの作成（あなたのオンライン上の身分証明）}
\begin{enumerate}
    \item GitHub公式サイトへアクセス: ブラウザでGitHubの公式サイト（\url{https://github.com}）を開き、画面右上の「Sign up」ボタンをクリックします。
    \item 情報の入力: 画面の指示に従い、メールアドレス、パスワード、ユーザー名を入力します。ユーザー名は、あなたの公開されるIDとなるため、慎重に選びましょう。
    \item メール認証: 登録したメールアドレスにGitHubから認証コードが記載されたメールが届きます。そのコードを画面に入力して、認証を完了させます。
\end{enumerate}

\subsection{パート3：Gitへの自己紹介（初回設定）}
インストールしたGitにあなたの情報を教える必要があります。これは、これからあなたが行うすべての「セーブ」（コミット）に、作成者としてあなたの名前と
メールアドレスが記録されるため、非常に重要です。
ターミナル（Windowsの場合はGit Bash）を開き、以下の2つのコマンドを一行ずつ実行してください。`"Your Name"`と`"your.email@example.com"`の部分は、
ご自身の名前に置き換えてください。メールアドレスはGitHubに登録したものと同じものを使うのが一般的です。
\begin{verbatim}
git config --global user.name "Your Name"
git config --global user.email "your.email@example.com"
\end{verbatim}
`--global` というオプションは、この設定をこのコンピュータ上のすべてのGitプロジェクトで共通して使用するという意味です。設定が正しく行われたかを確認するには、
以下のコマンドを実行します。
\begin{verbatim}
git config --list
\end{verbatim}
一覧の中に `user.name` と `user.email` が正しく表示されていれば、準備は完了です。

\section{最初のソロプロジェクト - 進捗をローカルに保存する}
ツールの準備が整いました。いよいよ、Gitを使って最初のプロジェクトを管理してみましょう。ここでは、あなたのコンピュータの中だけで完結する、基本的な流れを学びます。

\subsection{Gitの3つのエリア（比喩で理解する）}
Gitの操作を理解するためには、まず3つの主要な「場所」の概念を掴むことが重要です。これを、机仕事に例えてみましょう。
\begin{itemize}
    \item ワーキングディレクトリ (Working Directory) - あなたの「仕事机」: あなたが実際にファイルを作成したり、編集したりする場所です。
    \item ステージングエリア (Staging Area / Index) - 「提出用の下書きフォルダ」: 次の「セーブポイント」（コミット）に含めたい変更だけを一時的に置いておくための場所です。
    \item ローカルリポジトリ (Local Repository) - 「鍵付きの書類保管庫」: ステージングエリアにある変更内容を、メッセージ付きで永久に記録・保管する場所です。
    プロジェクトフォルダ内に作られる `.git` という隠しフォルダがその実体です。
\end{itemize}

\subsection{コアワークフローの実践}
それでは、簡単なウェブサイトのプロジェクトを例に、実際のコマンド操作を見ていきましょう。
\subsubsection{git init (保管庫の準備)}
まず、プロジェクト用のフォルダを作成し、そのフォルダに移動します。そして、`git init` コマンドを実行します。これにより、`.git` フォルダ（書類保管庫）が作成され、
バージョン管理が開始されます。
\begin{verbatim}
mkdir my-first-website
cd my-first-website
git init
\end{verbatim}

\subsubsection{git status (状況確認)}
このコマンドは、現在の「仕事机」と「下書きフォルダ」の状態を教えてくれます。どのファイルが変更され、何がセーブの準備ができているのかを確認できます。
\begin{verbatim}
# (index.htmlというファイルを作成した後で)
git status
\end{verbatim}

\subsubsection{git add (下書きフォルダへ移動)}
ファイルに変更を加えたら、それを次のセーブポイントに含めるためにステージングエリアに追加します。
\begin{verbatim}
# 特定のファイルを追加
git add index.html

# フォルダ内の全ての変更を追加（よく使う）
git add .
\end{verbatim}

\subsubsection{git commit (セーブポイントの作成)}
ステージングエリアにセーブしたい変更をすべて追加したら、コミットです。`git commit` は、分かりやすいラベル（コミットメッセージ）を付けて「書類保管庫」に永久保存する操作です。
\begin{verbatim}
git commit -m "最初のホームページHTMLを追加"
\end{verbatim}
この `add` -> `commit` というサイクルが、Gitを使った開発の基本的なリズムです。

\section{傑作を共有する - GitHubとの接続}
これまでの作業は、すべてあなたのコンピュータの中だけで完結していました。次に、このプロジェクトをGitHubに預けて、バックアップや共有ができるようにしましょう。

\subsection{シナリオA：ローカルで始めたプロジェクトをGitHubに公開する}
\begin{enumerate}
    \item GitHub上でリモートリポジトリを作成する: GitHubにログインし、「New repository」を作成します。リポジトリ名を入力し、「Public」または「Private」を選択して作成します。
    \item ローカルとリモートを紐付ける: ローカルリポジトリに、今作ったリモートリポジトリの場所を教えます。GitHubのリポジトリページに表示されているURLをコピーし、ターミナルで以下のコマンドを実行します。
    \begin{verbatim}
git remote add origin https://github.com/あなたのユーザー名/リポジトリ名.git
\end{verbatim}
    `origin` はリモートリポジトリに付ける標準的な「あだ名」です。
    \item 最初のプッシュ: ローカルリポジトリのコミット履歴を、GitHubにアップロード（プッシュ）します。
    \begin{verbatim}
git push -u origin main
\end{verbatim}
    `-u` は初回のみ必要な設定で、ローカルの `main` ブランチとリモートの `main` ブランチを関連付けます。次回からは `git push` だけで済みます。
\end{enumerate}

\subsection{シナリオB：GitHubに既にあるプロジェクトに参加する}
\subsubsection{git clone (クローン)}
リモートリポジトリの完全なコピー（歴史もすべて含む）を、あなたのPCに一度だけダウンロードしてくるコマンドです。
\begin{verbatim}
git clone https://github.com/他の人のユーザー名/プロジェクト名.git
\end{verbatim}

\subsubsection{git pull (プル)}
クローンした後、他の人がリモートリポジトリにプッシュした最新の変更を、あなたのローカルリポジトリに取り込むために `git pull` を使います。
\begin{verbatim}
git pull origin main
\end{verbatim}

\section{パラレルワールドの力 - ブランチ入門}
現在の安定したバージョンに影響を与えることなく、安全に新しい機能を試すための場所が「ブランチ」です。

\subsection{ブランチの比喩：パラレルワールド}
ブランチを作成するとは、プロジェクトの歴史から分岐した「パラレルワールド」を作り出すようなものです。
\begin{itemize}
    \item main ブランチ: プロジェクトの公式な歴史が記録されている「メインの世界線」。
    \item フィーチャーブランチ: 新機能開発やバグ修正のために作る「パラレルワールド」。何を試してもメインの世界線には影響がありません。
\end{itemize}

\subsection{ブランチ操作コマンド}
\subsubsection{ブランチの作成と切り替え}
ブランチを新しく作り、そのブランチに移動（チェックアウト）するには、以下のコマンドが最も一般的です。`-c` は "create"（作成）を意味します。
\begin{verbatim}
git switch -c login-feature
\end{verbatim}

\subsubsection{ブランチの一覧表示}
現在存在するブランチの一覧を表示し、今自分がどのブランチにいるか（`*` が付いている）を確認します。
\begin{verbatim}
git branch
\end{verbatim}

\subsubsection{既存ブランチへの切り替え}
`main` ブランチに戻るなど、すでに存在するブランチに移動します。
\begin{verbatim}
git switch main
\end{verbatim}

\subsection{git switch vs git checkout}
古いチュートリアルでは `git checkout` が使われていますが、これは多機能で分かりにくいことがあるため、ブランチ操作専用の `git switch` を使うことをお勧めします。
\begin{tabularx}{\textwidth}{|l|l|l|X|}
\hline
操作 & モダンなコマンド (git switch) & 古いコマンド (git checkout) & 推奨 \\ 
\hline
既存ブランチへ切り替え & `git switch feature` & `git checkout feature` & `switch` は意図が明確。 \ 
新規ブランチを作成して切り替え & `git switch -c new-feature` & `git checkout -b new-feature` & `switch -c` を推奨。 \ 
ファイルの復元 & (`git restore <file>` を使用) & `git checkout -- <file>` & 専用の `restore` を使うべき。 \ 
\hline
\end{tabularx}

\section{チームワークが夢を叶える - プルリクエストの流れ}
チームでは、フィーチャーブランチの変更を `main` に統合する前に、他のメンバーにレビューしてもらうのが一般的です。この仕組みがGitHub
の「プルリクエスト（Pull Request, PR）」です。

\subsection{プルリクエストの物語}
開発者「Alex」が、新しい問い合わせフォームを追加するタスクを担当する、という物語を通して流れを見ていきましょう。
\begin{enumerate}
    \item 最新の状態から始める:Alexは作業前に、リモートの `main` ブランチの最新の状態をローカルに取り込みます。
    \begin{verbatim}
git switch main
git pull origin main
\end{verbatim}
    \item フィーチャーブランチを作成する: 自分のタスク用のブランチを作成します。
    \begin{verbatim}
git switch -c alex-add-contact-form
\end{verbatim}
    \item 作業を行う: このブランチで実装を行い、`git add` と `git commit` を繰り返します。
    \item ブランチをプッシュする: 作業が完了したら、フィーチャーブランチをGitHubにプッシュします。
    \begin{verbatim}
git push origin alex-add-contact-form
\end{verbatim}
    \item プルリクエストを開く: GitHubのプロジェクトページで「Compare & pull request」ボタンを押し、変更のタイトルと説明を記述してプルリクエストを作成します。
    \item レビュープロセス: 他の開発者「Ben」がコードの変更点を確認し、コメントを残します。
    \item フィードバックを反映し、更新する: Alexはフィードバックを元にコードを修正し、再度 `git push` します。新しいコミットは自動的にプルリクエストに追加されます。
    \item マージ: Benが変更を「Approve」（承認）すると、管理者が「Merge pull request」ボタンをクリックし、変更が `main` ブランチに正式に取り込まれます。
    \item 後片付け: マージが完了したら、役目を終えたフィーチャーブランチは削除するのが一般的です。
\end{enumerate}

\section{時間軸が交わる時 - マージコンフリクトの解決}
チームで開発していると、いつか必ず「マージコンフリクト（衝突）」に遭遇します。これは、Gitが「同じファイルの同じ行を別々の方法で変更したため、どちらを正解と
すれば良いか自動で判断できません。人間が解決してください」と助けを求めているサインです。

\subsection{コンフリクトの具体例}
`style.css` というファイルで、Alexが文字色を `blue` に、Benが `red` に変更した場合、マージ時にコンフリクトが発生します。

\subsection{解決プロセス}
\begin{enumerate}
    \item コンフリクトの特定: `git status` を実行すると、どのファイルがコンフリクトしているか（`both modified` と表示される）を確認できます。
    \item ファイルを開く: コンフリクトしたファイルをエディタで開くと、Gitが以下のような特別なマーカーを自動で挿入しています。
    \begin{verbatim}
  color: blue;
\end{verbatim}
    `<<<<<<< HEAD` から `=======` までが現在のブランチの変更、`=======` から `>>>>>>>` までが相手のブランチの変更です。
    \item 意思決定を行う: 開発者であるあなたが、このブロックを編集して最終的なコードを決定します。例えば `color: red;` を採用する場合、マーカーをすべて削除し、
    その行だけを残します。
    \item 解決を確定する: ファイルの編集が終わったら、Gitに解決したことを伝えます。
    \begin{verbatim}
# 解決したファイルをステージングする
git add style.css

# 解決を記録するためのコミットを行う
git commit
\end{verbatim}
\end{enumerate}

\section{プロジェクトを整理整頓する - 必須のツールとテクニック}
\subsection{パート1：不要なファイルを無視する .gitignore}
プログラムのログや個人設定など、バージョン管理に含めるべきでないファイルは `.gitignore` ファイルで無視するよう設定します。これはプロジェクトのルートディレクトリに
配置するテキストファイルです。
\begin{verbatim}
# OSが自動生成するファイルを無視
.DS_Store
Thumbs.db

# ログファイルを無視
*.log

# 依存パッケージのフォルダを無視（npmの場合）
node_modules/

# 環境変数ファイル（秘密情報を含むことが多い）を無視
.env
\end{verbatim}
`*` はワイルドカード、行末の `/` はディレクトリ全体を意味します。`.gitignore` は、まだ追跡されていないファイルにのみ有効です。

\subsection{パート2：一歩進んだ歴史の整理 - merge vs. rebase}
ブランチの変更を統合する方法には `merge` と `rebase` があります。
\begin{itemize}
    \item git merge (ありのままの歴史): 2つのブランチの歴史をそのまま残し、統合のための新しい「マージコミット」を作成します。歴史は分岐と合流を繰り返す形になります。
    \item git rebase (歴史の書き換え): あなたのブランチの変更を、統合先ブランチの最新コミットの先端に付け直します。コミット履歴が一本の直線になり、きれいに見えます。
\end{itemize}
リベースの黄金律: 他のメンバーと共有しているブランチでは、決して `rebase` を使わないこと。歴史を書き換えるため、チームのリポジトリに深刻な混乱を引き起こす可能性があります。初心者の方は、常に安全な `merge` を使うようにしてください。

\appendix
\section{コマンド早見表}
\begin{tabularx}{\textwidth}{|l|X|}
\hline
コマンド & 何をするか \\ 
\hline
`git config --global user.name "Your Name"` & すべてのリポジトリで使うあなたのユーザー情報を設定する。 \ 
`git init` & 現在のフォルダに新しいローカルリポジトリを作成する。 \ 
`git clone [url]` & リポジトリとその全歴史をダウンロードする。 \ 
`git status` & ワーキングディレクトリとステージングエリアの状態を表示する。 \ 
`git add [file]` & ファイルの変更をステージングエリアに追加する (`.` ですべて)。 \ 
`git commit -m "[msg]"` & ステージされた変更をリポジトリの歴史に保存する。 \ 
`git push` & ローカルのコミットをリモートリポジトリにアップロードする。 \ 
`git pull` & リモートの最新の変更をダウンロードしてマージする。 \ 
`git switch -c [branch]` & 新しいブランチを作成し、そのブランチに切り替える。 \ 
`git switch [branch]` & 既存のブランチに切り替える。 \ 
`git branch` & ローカルのブランチを一覧表示する。 \ 
`git merge [branch]` & 指定したブランチを現在のブランチにマージする。 \ 
\hline
\end{tabularx}

\end{document}