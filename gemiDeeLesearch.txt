GitとGitHub初心者向け図解ガイド：最初のコマンドから共同作業まではじめに：あなたの旅がここから始まるプログラミングやウェブ制作の世界へようこそ。これから学ぶ多くのツールの中でも、Git（ギット）とGitHub（ギットハブ）は、現代の開発者にとって欠かせない存在です。しかし、多くの専門用語や黒い画面でのコマンド操作に、最初は戸惑いを感じるかもしれません。ご安心ください。この記事は、そんなあなたのためのガイドです。この旅では、複雑に見える概念を身近な比喩で解きほぐし、一つひとつのコマンド操作を丁寧に図解しながら、あなたのペースで進めていきます。まずは、この先で何度も登場する重要な言葉たちを、簡単な「翻訳機」を通して見てみましょう。これらの比喩が、あなたの理解を助ける羅針盤となるはずです。Git専門用語 翻訳機専門用語簡単な比喩簡単な説明バージョン管理 (Version Control)プロジェクトのタイムマシンファイルの変更履歴を記録し、いつでも過去の状態に戻せる仕組み。リポジトリ (Repository)プロジェクト専用の保管庫プロジェクトのファイルと、その全履歴が保存されている場所。コミット (Commit)セーブポイントファイルの特定の状態を「写真に撮って」履歴に保存する操作。ブランチ (Branch)パラレルワールドプロジェクトの歴史を分岐させ、安全に新しい作業を進めるための仕組み。マージ (Merge)パラレルワールドの統合分岐したブランチでの作業を、メインの歴史に合流させること。リモート (Remote)インターネット上の保管庫GitHubなど、ネットワーク上にあるリポジトリのこと。プッシュ (Push)ローカルからリモートへアップロード自分のPCで行った変更を、インターネット上のリポジトリに反映させること。プル (Pull)リモートからローカルへダウンロードインターネット上のリポジトリの最新の変更を、自分のPCに持ってくること。第1章：あなたが知らなかったタイムマシン（なぜバージョン管理が必要なのか？）レポートや企画書を作成している時、こんな経験はありませんか？ report_final.doc、report_final_v2.doc、report_final_REALLY_final.doc...。ファイル名がどんどん増えていき、どれが本当に最新版なのか分からなくなる。これは、多くの人が経験する「バージョン管理」の悩みです。システムがないと直面する問題システムを使わずに手作業でファイルのバージョンを管理しようとすると、いくつかの問題が必ず発生します。何かを壊すことへの恐怖: 「この一行を変えたら、全部動かなくなるかも…」という不安から、変更を加えるたびにファイルのコピーを延々と作り続けることになります。これは非効率的で、ディスク容量も圧迫します 1。過去の作業の喪失: 誤ってファイルを上書きしてしまい、以前の良かったバージョンを永遠に失ってしまうことがあります。「元に戻す」機能では救えない、致命的なミスにつながる可能性があります 1。共同作業のカオス: 複数人で作業する場合、メールでファイルを送り合うのは悪夢の始まりです。誰かが加えた変更を自分のファイルに手作業で取り込み、気づかぬうちに他の人の修正を上書きしてしまうことも珍しくありません。「この変更は誰が、いつ、なぜ行ったのか？」という問いに答える術がなくなります 1。解決策：セーフティネットとしてのバージョン管理Gitのようなバージョン管理システム（Version Control System, VCS）は、これらの問題を解決するための強力なセーフティネットです。完全な履歴の記録: VCSは、ファイルに加えられた全ての変更を記録します。誰が、いつ、どのような目的で変更したのか、そのすべてが記録として残ります 3。これは、プロジェクトの信頼できる航海日誌のようなものです。自在なタイムトラベル: プロジェクトの歴史の中の、どの時点にでも簡単かつ正確に戻ることができます。これは単なる「元に戻す」操作ではありません。歴史上の任意の「セーブポイント」へ瞬時にジャンプするタイムトラベルです 1。この機能があるからこそ、開発者は失敗を恐れずに新しいアイデアを試すことができるのです。構造化された共同作業: VCSは、複数人が同じプロジェクトで効率的に作業するための明確なルールと仕組みを提供します。他の人の作業を上書きしてしまう心配なく、それぞれの変更を安全に統合できます 1。バージョン管理の最も重要な価値は、技術的な機能そのものよりも、それがもたらす「心理的安全性」にあります。それは「どれだけ大胆な変更を加えても、いつでも元に戻せる」という安心感です。この安心感が、学習や創造性を加速させる土台となるのです。Gitは単なるツールではなく、あなたの挑戦を支える強力な味方です。第2章：GitとGitHub - 言語と図書館初心者が最初につまずきやすいのが、「Git」と「GitHub」の違いです。この二つは密接に関連していますが、全く異なるものです。この違いを理解するために、いくつかの比喩を使ってみましょう。中核となる違いと比喩Gitは「言語」である: Gitは、あなたのコンピュータにインストールして使うソフトウェアそのものです。ファイルの変更を追跡し、履歴を管理するためのルールやコマンドの体系、いわば「バージョン管理という言語」です。この言語は、あなたのPC（ローカル環境）の中で話されます 6。GitHubは「国」であり「図書館」である: GitHubは、インターネット上で提供されるウェブサービスです。そこは「Gitという言語」が公用語として話されている「国」のような場所です 6。世界中の開発者が自分のプロジェクト（リポジトリ）を保管し、公開し、他の人々と共同作業を行うための、巨大なオンライン「図書館」とも言えます。この関係を、より身近な例で補強してみましょう。「メールとGmail」の関係に似ています 7。メールは世界共通の通信の仕組み（プロトコル）ですが、GmailはGoogleが提供する便利な機能（ウェブインターフェース、検索、迷惑メールフィルタなど）を備えたメールサービスです。同様に、Gitはバージョン管理の仕組みであり、GitHubはその仕組みを使いやすくし、共同作業のための強力な機能を追加したサービスなのです。コード スニペットgraph LR
    subgraph あなたのPC (ローカル)
        A[Git]
    end
    subgraph インターネット (クラウド)
        B[GitHub]
    end
    A -- push（アップロード） --> B
    B -- pull/clone（ダウンロード） --> A
なぜ両方が必要なのか？Gitだけでも、個人のプロジェクトを管理することは可能です。しかし、GitHub（やGitLab、Bitbucketといった類似のサービス）を組み合わせることで、Gitの真価が発揮されます。GitHubは、あなたのプロジェクトのバックアップ場所として機能し、他の開発者とコードを共有し、チームでの作業を円滑に進めるためのプラットフォームを提供します 8。Gitというスキル（言語）を身につければ、GitHubだけでなく、GitLabなど他の「国」でも活躍できるのです 6。第3章：開発者のツールキットを揃えようここからは、実際に手を動かして、あなたの開発環境を整えていきましょう。職人が仕事道具を揃えるように、この一度きりのセットアップが、これからのすべての作業の基礎となります。パート1：Gitのインストール（道具を手に入れる）Windowsの場合インストーラーのダウンロード: まずはGitの公式サイト（git-scm.com）にアクセスし、Windows用のインストーラーをダウンロードします 9。インストールの実行: ダウンロードした .exe ファイルを実行します。インストールウィザードが起動しますが、たくさんの選択肢が表示されて戸惑うかもしれません 11。しかし、初心者の方は、基本的にすべての画面でデフォルト設定のまま「Next」をクリックし続けて問題ありません 9。インストールの確認: インストールが完了したら、スタートメニューから「Git Bash」を起動するか、PowerShellまたはコマンドプロンプトを開きます。そこで以下のコマンドを入力してください。Bashgit --version
git version 2.XX.X のようにバージョン情報が表示されれば、インストールは成功です 9。macOSの場合macOSにはGitをインストールする方法がいくつかありますが、ここでは最も一般的で推奨される方法を紹介します。インストールの確認: まず、Gitがすでにインストールされていないか確認します。ターミナルアプリを開き、以下のコマンドを入力してください。Bashgit --version
すでにバージョンが表示された場合、Gitは利用可能です。ただし、最新版を使いたい場合は次のステップに進むことをお勧めします 14。Homebrewのインストール（推奨）: Homebrewは、macOS用のパッケージ管理システムで、ソフトウェアのインストールやアップデートを簡単にしてくれます。まだインストールしていない場合は、ターミナルで公式サイト（brew.sh）に記載されているコマンドを実行してインストールしてください。Gitのインストール: Homebrewがインストールできたら、ターミナルで以下のコマンドを実行するだけでGitがインストールされます 15。Bashbrew install git
この方法の利点は、将来的に brew upgrade git という簡単なコマンドでGitを最新の状態に保てることです。パート2：GitHubアカウントの作成（あなたのオンライン上の身分証明）GitHub公式サイトへアクセス: ブラウザでGitHubの公式サイト（github.com）を開き、画面右上の「Sign up」ボタンをクリックします 17。情報の入力: 画面の指示に従い、メールアドレス、パスワード、ユーザー名を入力します。ユーザー名は、あなたの公開されるIDとなるため、慎重に選びましょう 19。メール認証: 登録したメールアドレスにGitHubから認証コードが記載されたメールが届きます。そのコードを画面に入力して、認証を完了させます 17。アンケート: 登録後、利用目的などに関するアンケートが表示されることがありますが、これらはスキップしても問題ありません 18。パート3：Gitへの自己紹介（初回設定）最後に、インストールしたGitにあなたの情報を教える必要があります。これは非常に重要なステップです。なぜなら、これからあなたが行うすべての「セーブ」（コミット）には、作成者としてあなたの名前とメールアドレスが記録されるからです 14。ターミナル（Windowsの場合はGit Bash）を開き、以下の2つのコマンドを一行ずつ実行してください。"Your Name"と"your.email@example.com"の部分は、ご自身の名前に置き換えてください。メールアドレスはGitHubに登録したものと同じものを使うのが一般的です。Bashgit config --global user.name "Your Name"
git config --global user.email "your.email@example.com"
--global というオプションは、この設定をこのコンピュータ上のすべてのGitプロジェクトで共通して使用するという意味です 14。設定が正しく行われたかを確認するには、以下のコマンドを実行します。Bashgit config --list
一覧の中に user.name と user.email が正しく表示されていれば、準備は完了です 22。第4章：最初のソロプロジェクト - 進捗をローカルに保存するツールの準備が整いました。いよいよ、Gitを使って最初のプロジェクトを管理してみましょう。ここでは、あなたのコンピュータの中だけで完結する、基本的な流れを学びます。Gitの3つのエリア（比喩で理解する）Gitの操作を理解するためには、まず3つの主要な「場所」の概念を掴むことが重要です。これを、机仕事に例えてみましょう。ワーキングディレクトリ (Working Directory) - あなたの「仕事机」:これは、あなたのPC上にあるプロジェクトのフォルダそのものです。あなたが実際にファイルを作成したり、編集したりする場所です。ステージングエリア (Staging Area / Index) - 「提出用の下書きフォルダ」:これは、次の「セーブポイント」（コミット）に含めたい変更だけを一時的に置いておくための場所です。仕事机の上が散らかっていても、完成した書類だけをこのフォルダに入れることで、セーブする内容を厳選できます。ローカルリポジトリ (Local Repository) - 「鍵付きの書類保管庫」:これは、ステージングエリアにある変更内容を、メッセージ付きで永久に記録・保管する場所です。プロジェクトフォルダ内に作られる .git という隠しフォルダがその実体です。一度ここに保管された記録は、簡単には失われません。この3つのエリアの関係を図にすると、以下のようになります。コード スニペットgraph TD
    A[ワーキングディレクトリ<br>（仕事机）] -- git add --> B[ステージングエリア<br>（下書きフォルダ）];
    B -- git commit --> C[ローカルリポジトリ<br>（書類保管庫）];
    C -- git checkout/restore --> A;
コアワークフローの実践それでは、簡単なウェブサイトのプロジェクトを例に、実際のコマンド操作を見ていきましょう。git init (保管庫の準備):まず、プロジェクト用のフォルダを作成し、そのフォルダに移動します。そして、git init コマンドを実行します。これは「Git、このフォルダの監視を始めてくれ！」と指示するようなものです。このコマンドにより、.git フォルダ（書類保管庫）が作成され、バージョン管理が開始されます 24。Bashmkdir my-first-website
cd my-first-website
git init
git status (状況確認):このコマンドは、あなたの最も親しい友人になります。現在の「仕事机」と「下書きフォルダ」の状態を教えてくれます。どのファイルが新しく作られ、どのファイルが変更され、何がセーブの準備ができているのかを一目で確認できます。Bash# (index.htmlというファイルを作成した後で)
git status
git add (下書きフォルダへ移動):ファイルに変更を加えたら、それを次のセーブポイントに含めるためにステージングエリアに追加します。これが git add コマンドの役割です。「仕事机」の上にある完成したファイルを、「提出用の下書きフォルダ」へ移動させるイメージです 24。Bash# 特定のファイルを追加
git add index.html

# フォルダ内の全ての変更を追加（よく使う）
git add.
git commit (セーブポイントの作成):ステージングエリアにセーブしたい変更をすべて追加したら、いよいよコミットです。git commit は、「下書きフォルダ」にあるものすべてをまとめて、分かりやすいラベル（コミットメッセージ）を付けて「書類保管庫」に永久保存する操作です 24。コミットメッセージは、「何を変更したのか」を簡潔に説明する非常に重要な記録です。-m オプションを使ってメッセージを指定します。Bashgit commit -m "最初のホームページHTMLを追加"
この add -> commit というサイクルが、Gitを使った開発の基本的なリズムです。小さな変更を積み重ね、その都度意味のあるセーブポイントを作成していくことが、良いバージョン管理の鍵となります。第5章：傑作を共有する - GitHubとの接続これまでの作業は、すべてあなたのコンピュータの中だけで完結していました。次に、このプロジェクトをGitHubという「オンラインの図書館」に預けて、バックアップや他人との共有ができるようにしましょう。シナリオA：ローカルで始めたプロジェクトをGitHubに公開するステップ1：GitHub上でリモートリポジトリを作成するまず、GitHubのウェブサイトにログインし、新しいリポジトリを作成します。通常、画面右上の「+」アイコンから「New repository」を選択します。リポジトリ名を入力し、「Public」（公開）または「Private」（非公開）を選択して、「Create repository」ボタンをクリックします。この時点では、まだ空っぽの保管庫がオンライン上に作られただけです。ステップ2：ローカルとリモートを紐付ける次に、あなたのローカルリポジトリ（PC上の保管庫）に、今作ったリモートリポジトリ（GitHub上の保管庫）の場所を教える必要があります。これを「リモートの追加」と呼びます。GitHubのリポジトリページに表示されているURL（HTTPS形式のものが簡単です）をコピーします。そして、ターミナルで以下のコマンドを実行します 26。Bashgit remote add origin https://github.com/あなたのユーザー名/リポジトリ名.git
このコマンドを分解してみましょう。git remote add: 新しいリモート接続を追加するという命令です。origin: 追加するリモートリポジトリに付ける「あだ名」です。これは慣習的に origin と呼ばれますが、魔法の言葉ではなく、単なる標準的なショートカットです 26。https://...: 先ほどコピーしたリモートリポジトリのURLです。これで、ローカルリポジトリは origin という名前でリモートリポジトリの場所を覚えました。ステップ3：最初のプッシュいよいよ、ローカルリポジトリに保存したコミット（セーブポイントの歴史）を、GitHub上のリモートリポジトリにアップロードします。この操作を push（プッシュ）と呼びます 25。最初のプッシュでは、少し特別なコマンドを使います。Bashgit push -u origin main
-u (または --set-upstream): これは初回のみ必要な設定で、「ローカルの main ブランチは、リモート (origin) の main ブランチを追跡するように」と関連付けるためのものです。この設定をしておけば、次回からは単に git push と入力するだけで済みます。このコマンドを実行すると、GitHubのリポジトリページをリロードした際に、あなたのファイルとコミット履歴が反映されているはずです。シナリオB：GitHubに既にあるプロジェクトに参加するgit clone と git pullここまではあなたがローカルで「始めた」プロジェクトの話でした。では、誰かがすでにGitHub上で進めているプロジェクトに参加したい場合はどうすればよいでしょうか。git clone (クローン):これは、リモートリポジトリの完全なコピー（歴史もすべて含む）を、あなたのPCに一度だけダウンロードしてくるコマンドです 30。init -> remote add -> push の流れを一度にやってくれるようなものです。Bashgit clone https://github.com/他の人のユーザー名/プロジェクト名.git
git pull (プル):一度クローンした後は、他の人がリモートリポジトリにプッシュした最新の変更を、あなたのローカルリポジトリに取り込むために git pull を使います 31。これは「最新の変更をダウンロードして、自分の作業内容と統合する」という、日常的に使うコマンドです。Bashgit pull origin main
このように、プロジェクトの開始状況によって使うコマンドが異なります。この2つのシナリオを理解することが、リモートリポジトリを扱う上での第一歩です。第6章：パラレルワールドの力 - ブランチ入門もし、ウェブサイトに新しいログイン機能を追加したいと考えたとします。しかし、開発の途中でサイト全体が動かなくなってしまったら困ります。そんな時、現在の安定したバージョンに影響を与えることなく、安全に新しい機能を試すための場所が欲しくなります。その解決策が「ブランチ」です 33。ブランチの比喩：パラレルワールドブランチを作成するとは、プロジェクトの歴史から分岐した「パラレルワールド」を作り出すようなものです 34。main ブランチ: あなたのプロジェクトの公式な歴史が記録されている「メインの世界線」。ここは常に安定していて、いつでも動く状態を保ちます。フィーチャーブランチ: 新機能開発やバグ修正のために作る「パラレルワールド」。例えば login-feature というブランチを作ると、その時点の main ブランチの完全なコピーが新しい世界線として生まれます。このパラレルワールドでは、何を試してもメインの世界線には一切影響がありません。実験が成功すれば、その変更をメインの世界線に統合（マージ）します。もし失敗しても、そのパラレルワールドを捨てるだけで、メインの世界線は無傷のままです。技術的には、ブランチは特定のコミットを指し示す単なる軽量なポインタ（付箋のようなもの）に過ぎません 34。そのため、作成や切り替えが非常に高速に行えます。ブランチ操作コマンドブランチの作成と切り替え:ブランチを新しく作り、そのブランチに移動（チェックアウト）するには、以下のコマンドが最も一般的です。-c は "create"（作成）を意味します。Bashgit switch -c login-feature
ブランチの一覧表示:現在存在するブランチの一覧を表示し、今自分がどのブランチにいるか（* が付いている）を確認します。Bashgit branch
既存ブランチへの切り替え:main ブランチに戻るなど、すでに存在するブランチに移動します。Bashgit switch main
git switch vs git checkout古いチュートリアルや記事では、ブランチの切り替えに git checkout というコマンドが使われているのをよく見かけます。checkout はブランチの切り替えだけでなく、ファイルの復元など、複数の機能を持つ多目的ツールでした。そのため、初心者にとっては意図が分かりにくく、混乱の原因となることがありました 36。近年、Gitにはブランチ操作専用の、より安全で分かりやすいコマンドが導入されました。それが git switch です 38。これから学ぶあなたは、積極的に git switch を使うことをお勧めします。操作モダンなコマンド (git switch)古いコマンド (git checkout)推奨既存ブランチへ切り替えgit switch featuregit checkout featureswitch は意図が明確。新規ブランチを作成して切り替えgit switch -c new-featuregit checkout -b new-featureswitch -c を推奨。-c は "create" で直感的。ファイルの復元( git restore <file> を使用)git checkout -- <file>checkout のファイル復元機能は混乱の元。専用の restore を使うべき。この違いを認識しておくことで、古い情報に惑わされることなく、現代的で安全なGitの操作を身につけることができます。ブランチの可視化ブランチがどのように分岐し、再び合流するのかを視覚的に理解することは非常に重要です。以下は、その流れをMermaid.jsという記法で表現した図です。コード スニペットgitGraph
    commit id: "C1"
    commit id: "C2"
    branch feature-A
    checkout feature-A
    commit id: "A1"
    commit id: "A2"
    checkout main
    commit id: "C3"
    merge feature-A id: "M1"
この図は、main ブランチから feature-A ブランチが分岐し、それぞれで作業が進んだ後、main ブランチにマージされる様子を示しています。このように、ブランチを使うことで、複数の作業を並行して安全に進めることができるのです。第7章：チームワークが夢を叶える - プルリクエストの流れブランチは個人作業でも便利ですが、その真価はチームでの共同開発で発揮されます。チームでは、フィーチャーブランチで行った変更を main ブランチに統合する前に、他のメンバーにレビュー（査読）してもらうのが一般的です。この一連のプロセスを円滑に進めるための仕組みが、GitHubの「プルリクエスト（Pull Request, PR）」です 40。プルリクエストは、単にコードをマージする技術的な操作ではありません。それは「私がこんな変更を加えたので、内容を確認して問題なければ main に取り込んでください」という、チームに対する提案であり、変更内容について議論するためのコミュニケーションハブなのです。プルリクエストの物語開発者の「Alex」が、新しい問い合わせフォームを追加するタスクを担当する、という物語を通してプルリクエストの流れを見ていきましょう。最新の状態から始める:Alexは作業を始める前に、まずリモートの main ブランチの最新の状態をローカルに取り込みます。Bashgit switch main
git pull origin main
フィーチャーブランチを作成する:次に、自分のタスク用のブランチを作成して、そちらに移動します。Bashgit switch -c alex-add-contact-form
作業を行う:Alexは、このブランチで問い合わせフォームの実装を行います。作業の区切りが良いところで、git add と git commit を繰り返して、変更履歴を記録していきます。ブランチをプッシュする:作業が完了したら、Alexは自分のフィーチャーブランチをGitHubにプッシュします。これにより、他のチームメンバーもこのブランチの存在と変更内容を見ることができるようになります。Bashgit push origin alex-add-contact-form
プルリクエストを開く:GitHubのプロジェクトページに行くと、「alex-add-contact-form had recent pushes」という通知と共に「Compare & pull request」ボタンが表示されています。Alexはこのボタンをクリックします 41。プルリクエスト作成画面で、変更のタイトルと、なぜこの変更が必要で、何をしたのかを具体的に説明します。レビュー担当者が変更の意図を理解しやすいように、分かりやすく書くことが重要です 42。レビュープロセス:チームの別の開発者「Ben」にレビューが依頼されます。Benはプルリクエストの「Files Changed」タブを開き、Alexが加えたコードの変更点を一行ずつ確認します。もし気になる点があれば、Benは特定のコード行に対して「ここの変数名はもっと分かりやすい方が良いのでは？」といったコメントを残します 43。フィードバックを反映し、更新する:AlexはBenからのフィードバックを受け、ローカルの alex-add-contact-form ブランチでコードを修正し、新しいコミットを作成します。そして、再度 git push を実行するだけです。新しいコミットは、自動的に既存のプルリクエストに追加され、Benは更新された内容を再度レビューできます 44。マージ:Benが変更内容に納得し、「Approve」（承認）すると、プルリクエストはマージ可能な状態になります。プロジェクトの管理者がGitHub上で「Merge pull request」ボタンをクリックすると、alex-add-contact-form ブランチの変更が main ブランチに正式に取り込まれます 43。後片付け:マージが完了すると、役目を終えたフィーチャーブランチは削除するのが一般的です。この一連の流れを図で示すと、以下のようになります。コード スニペットgitGraph
    commit id: "main-1"
    branch alex-feature
    checkout alex-feature
    commit id: "feat-1"
    commit id: "feat-2 (feedback)"
    checkout main
    merge alex-feature id: "PR Merge"
    commit id: "main-2"
プルリクエストを効果的に使うには、技術的な操作だけでなく、明確な説明を書く、フィードバックに丁寧に対応するといった「プルリクエストのマナー」も同様に重要です。小さく、目的に集中したプルリクエストを心がけることが、スムーズなチーム開発の秘訣です 43。第8章：時間軸が交わる時 - マージコンフリクトの解決チームで開発していると、いつか必ず遭遇するのが「マージコンフリクト（衝突）」です。コンフリクトはエラーや失敗ではなく、チーム開発におけるごく自然な現象です 46。コンフリクトとは、Gitが「AlexとBenが、同じファイルの同じ行を別々の方法で変更したため、どちらを正解とすれば良いか自動で判断できません。人間のあなたが決めてください」と助けを求めているサインなのです。コンフリクトの具体例style.css というファイルに、以下のような記述があったとします。CSSp {
  color: #333333;
}
Alexは自分のブランチで、文字色を青に変更しました: color: blue;Benは別のブランチで、同じ行を赤に変更しました: color: red;Alexが自分のブランチを main にマージした後、Benが自分のブランチをマージしようとすると、Gitは同じ行に2つの異なる変更が加えられたことを検知し、コンフリクトが発生します。解決プロセスコンフリクトを解決するのは、一見怖そうに見えますが、手順を踏めば難しくありません。コンフリクトの特定:マージを試みた際にエラーメッセージが表示されます。git status コマンドを実行すると、どのファイルがコンフリクトしているか（both modified と表示される）を正確に知ることができます 47。ファイルを開く:コンフリクトが発生したファイルをテキストエディタで開きます。コンフリクトマーカーを解読する:Gitは、コンフリクト箇所に以下のような特別なマーカーを自動で挿入します 46。CSSp {
<<<<<<< HEAD
  color: blue;
=======
  color: red;
>>>>>>> ben-branch
}
このマーカーは、コンフリクトの「文法」です。<<<<<<< HEAD: ここから ======= までが、あなたの現在いるブランチ（この場合は main）での変更内容です。=======: 「あなたの変更」と「相手の変更」の区切り線です。>>>>>>> ben-branch: ここまでが、マージしようとしている ben-branch からの変更内容です。意思決定を行う:開発者であるあなたの仕事は、このブロックを編集して、最終的にどうあるべきかを決めることです。選択肢はいくつかあります。Alexの変更（青）を採用する。Benの変更（赤）を採用する。両方の良いところを取る、あるいは全く新しいコードを書く。例えば、今回はBenの変更を採用することに決めたとします。その場合、ファイルの内容を以下のように編集します。重要なのは、最終的なコードだけを残し、<<<<<<<, =======, >>>>>>> といったマーカーはすべて削除することです。CSSp {
  color: red;
}
解決を確定する:ファイルの編集が終わったら、Gitに「このファイルのコンフリクトは解決しました」と伝える必要があります。Bash# 解決したファイルをステージングする
git add style.css

# 解決を記録するためのコミットを行う
git commit
git commit を実行すると、Gitが用意したデフォルトのコミットメッセージ（例: "Merge branch 'ben-branch' into main"）と共にエディタが開くので、そのまま保存して閉じればマージは完了です。コンフリクトマーカーの見た目に最初は圧倒されるかもしれませんが、その構造は常に同じです。冷静にマーカーを読み解き、どちらの変更を残すべきか、あるいはどう統合すべきかを判断することが、コンフリクト解決の鍵です。第9章：プロジェクトを整理整頓する - 必須のツールとテクニックプロジェクトが成長するにつれて、ファイルを整理し、歴史をきれいに保つための「良い習慣」が重要になります。ここでは、すべての開発者が知っておくべき、いくつかの必須テクニックを紹介します。パート1：不要なファイルを無視する .gitignoreプロジェクトの中には、バージョン管理に含めるべきでないファイルが自動的に生成されることがあります。例えば、プログラムの実行ログ、個人のエディタ設定ファイル、APIキーなどの秘密情報が含まれるファイルなどです 48。これらのファイルを誤ってリポジトリに含めてしまうと、リポジトリが肥大化したり、セキュリティ上のリスクになったりします。この問題を解決するのが .gitignore ファイルです。これは、Gitに「このファイルやフォルダは無視してね」と伝えるための、ただのテキストファイルです 50。プロジェクトのルートディレクトリに .gitignore という名前のファイルを作成し、無視したいファイルやフォルダのパターンを一行ずつ記述します。一般的な .gitignore の記述例:# OSが自動生成するファイルを無視
.DS_Store
Thumbs.db

# ログファイルを無視
*.log
debug.log

# 依存パッケージのフォルダを無視（npmの場合）
node_modules/

# 環境変数ファイル（秘密情報を含むことが多い）を無視
.env
* はワイルドカードとして機能し、*.log は拡張子が .log のすべてのファイルを意味します 51。行の最後に / を付けると、その名前のディレクトリ全体を無視します 51。# で始まる行はコメントとして扱われます。重要な注意点: .gitignore は、まだ一度もGitの追跡対象になっていないファイルにのみ有効です。もしすでに追跡してしまったファイルを後から無視したい場合は、まず git rm --cached <file> コマンドで追跡対象から外す必要があります。パート2：一歩進んだ歴史の整理 - merge vs. rebaseこれは少し高度なトピックですが、Gitに慣れてきたら知っておくと良い概念です。ブランチの変更を統合する方法には、これまで使ってきた merge の他に rebase という選択肢があります。git merge (ありのままの歴史):これは、2つのブランチの歴史をそのまま残し、それらを統合するための新しい「マージコミット」を作成する方法です。歴史は分岐と合流を繰り返す形になり、「実際に作業が並行して行われた」という事実が正確に記録されます 53。git rebase (歴史の書き換え):これは、あなたのブランチの変更を一旦取り外し、統合先ブランチの最新のコミットの先端に、一つずつ付け直す（再適用する）ような操作です。結果として、コミット履歴が一本の直線になり、あたかもすべての作業が順番に行われたかのように見えます。歴史がきれいになるという利点があります 53。コード スニペット%% マージの例
gitGraph
    commit
    commit
    branch feature
    checkout feature
    commit
    checkout main
    commit
    merge feature
コード スニペット%% リベースの例
gitGraph
    commit
    commit
    branch feature
    checkout feature
    commit
    checkout main
    commit
    checkout feature
    rebase main
リベースの黄金律rebase は歴史をきれいに見せる強力なツールですが、コミットの歴史を「書き換える」という危険な側面も持っています。そのため、絶対に守らなければならないルールがあります。他の人と共有しているブランチでは、決して rebase を使わないこと。もしチームメンバーがすでにプッシュしているブランチに対して rebase を行うと、彼らのローカルの歴史と食い違いが生じ、リポジトリが修復困難な混乱に陥る可能性があります 53。初心者への推奨:Gitの仕組みとチームのワークフローを完全に理解するまでは、常に merge を使うようにしてください 56。merge は安全で、何が起こったのかを正直に記録してくれます。付録：コマンド早見表このガイドで学んだ主要なコマンドを一覧にまとめました。困ったときのリファレンスとしてご活用ください。コマンド何をするか一般的な使用例git config --globalすべてのリポジトリで使うあなたのユーザー情報を設定する。git config --global user.name "Your Name"git init現在のフォルダに新しいローカルリポジトリを作成する。git initgit clone [url]リポジトリとその全歴史をダウンロードする。git clone https://github.com/user/repo.gitgit statusワーキングディレクトリとステージングエリアの状態を表示する。git statusgit add [file]ファイルの変更をステージングエリアに追加する。git add index.html または git add.git commit -m "[msg]"ステージされた変更をリポジトリの歴史に保存する。git commit -m "ナビゲーションバーを追加"git pushローカルのコミットをリモートリポジトリにアップロードする。git push origin maingit pullリモートの最新の変更をダウンロードしてマージする。git pull origin maingit switch -c [branch]新しいブランチを作成し、そのブランチに切り替える。git switch -c new-featuregit switch [branch]既存のブランチに切り替える。git switch maingit branchローカルのブランチを一覧表示する。git branchgit merge [branch]指定したブランチを現在のブランチにマージする。git merge new-feature